---
title: "CEVE 543 Fall 2025 Lab 6: Julia Climate Data Tools"
subtitle: "YAXArrays.jl, NetCDF.jl, exploring CMIP6 data structure"
author: Alisa Sannikova
date: "2025-10-17"
type: "lab"
module: 2
week: 9
objectives:
  - "Load and explore climate model output using YAXArrays.jl"
  - "Work with NetCDF files and understand CMIP6 data structure"
  - "Extract and visualize climatquarto render index.qmd --to typste model data for specific locations and time periods"
  - "Establish foundation for downscaling and bias correction exercises"
ps_connection: "Establishes data handling skills needed for all PS2 problems working with climate model output"

engine: julia

format:
  html:
    toc: true
    toc-depth: 2
    code-block-bg: "#f8f8f8"
    code-block-border-left: "#e1e4e5"
    theme: simplex
    number-sections: true
    fig-format: svg
  typst:
    fontsize: 11pt
    margin: 
      x: 1in
      y: 1in
    number-sections: true
    fig-format: svg

execute: 
  cache: true
  freeze: auto

# Code formatting options
code-overflow: wrap
code-line-numbers: false
code-block-font-size: "0.85em"
---

## Background

Python's xarray package has been transformative for working with labeled multi-dimensional arrays in climate science.
Originally developed at The Climate Corporation and released as open source in 2014, xarray has become the standard tool for climate data analysis in Python.
Julia has been less widely adopted in this space, but the [Climate Modeling Alliance](https://clima.caltech.edu/) is building an Earth System Model from scratch in Julia, driving development of climate data tools in the Julia ecosystem.

The Julia approach offers distinct advantages for this course.
Because Julia is fast and doesn't require switching to C, Fortran, or C++ for performance-critical code, we can implement statistical methods and algorithms in pure Julia and apply them directly to climate data.
This means you can write custom downscaling algorithms, bias correction methods, and statistical models without learning specialized library syntax or dealing with language interoperability issues.
The resulting code is often easier to understand and maintain because everything stays in one language.

xarray remains excellent and widely used in practice.
However, for this course's focus on implementing and understanding statistical downscaling methods, Julia's combination of high performance and readability makes it easier to write, test, and apply custom algorithms to real climate data.

## Objectives

1. Load and explore climate model output using YAXArrays.jl
1. Work with NetCDF files and understand CMIP6 data structure
1. Extract and visualize climate model data for specific locations and time periods

## Before

::: {.callout-important}
## Instructions

Before starting the lab, uncomment the `Pkg.instantiate()` line in the first code block and run it to install all required packages.
This will take a few minutes the first time.
After installation completes, comment the line back out to avoid reinstalling on subsequent runs.
:::

## Tasks

All packages that you need are included, and will be installed when you `instantiate` the project.

1. Work through the [Getting Started with YAXArrays.jl](https://juliadatacubes.github.io/YAXArrays.jl/dev/get_started.html) user guide and implement the examples in this lab. Note that you will need to modify the code block to use `using ...` for all packages. 
  - You can copy or paste the code blocks from the tutorial, but try to make sure you understand what each line is doing.
  - It's good practice to put all your `using` statements at the top of your code blocks. As work through more tutorials, put all the `using ...` statements together. Often, it's helpful to sort them alphabetically or in another logical order.
  - DO add brief text between code blocks -- think of this as your notes to yourself
2. A lot of the functionality of `YAXArrays.jl` comes from from [`DimensionalData.jl`](https://rafaqz.github.io/DimensionalData.jl/stable/basics). In particular, functions for selecting subsets of data, and for grouping and aggregating data are provided in `DimensionalData`.
  - Read through the [Dimensions](https://rafaqz.github.io/DimensionalData.jl/stable/dimensions), [Selectors](https://rafaqz.github.io/DimensionalData.jl/stable/selectors), and other sections of the `DimensionalData` documentation under "Getting Started"
  - Work through the `YAXArrays` [tutorial on selecting data](https://juliadatacubes.github.io/YAXArrays.jl/dev/UserGuide/select.html)
    - Pro tip: replace `path = download(url, fname)` with `if !isfile(fname); download(url, fname); end` to avoid re-downloading the file every time you run the code block
3. Working through tutorials can get repetitive, so you don't need to implement every YAXArrays user guide. However, do take a few minutes to browse through the other available guides so you're aware of what functionality exists when you need it later.
4. Work through the [Plotting Maps](https://juliadatacubes.github.io/YAXArrays.jl/dev/tutorials/plottingmaps.html) tutorial
  - Instead of `GLMakie`, we will use `CairoMakie`. You can replace `using GLMakie` and `using GLMakie.GeometryBasics` with `using CairoMakie` and `using CairoMakie.GeometryBasics`. Read more about Makie backends [here](https://docs.makie.org/dev/explanations/backends/backends)
  - Don't worry about the `AlgebraofGraphics.jl` component, although it is installed if you want to try.
5. The `store ="gs://cmip6/CMIP6/ScenarioMIP/DKRZ/MPI-ESM1-2-HR/ssp585/r1i1p1f1/3hr/tas/gn/v20190710/"` for the Plotting Maps tutorial is actually quite powerful.
  - What are we working with? Refer to the [CMIP6 Data Reference Syntax](https://pcmdi.llnl.gov/CMIP6/Guide/dataUsers.html) for more information on the file structure used
    - `cmip6`: name of the top-level Google Cloud storage bucket (hence `gs`)
    - `CMIP6`: root directory for the project
    - `ScenarioMIP`: MIP (Model Intercomparison Project) name
    - `DKRZ`: institution ID (here, the German Climate Computing Center)
    - `MPI-ESM1-2-HR`: source ID (here, the Max Planck Institute Earth System Model, version 1-2, high resolution version)
    - `ssp585`: experiment ID (here, the Shared Socioeconomic Pathway 5-8.5, a very high emissions scenario)
    - `r1i1p1f1`: variant label. `r1` is realization 1 (this would change for different ensemble members, if available). `i1` is initialization method 1. `p1` is physics version 1. `f1` is forcing index 1
    - `3hr`: time frequency (3-hourly data)
    - `tas`:  variable ID (near-surface air temperature)
    - `gn`: grid label (native grid)
    - `v20190710`: version (version date)
  - Select a single rectangular region. Compute the average `tas` over that region (if you're fancy, weight by the cosine of latitude to account for the decreasing area of grid cells towards the poles, as shown in [this xarray example](https://docs.xarray.dev/en/latest/examples/area_weighted_temperature.html)) and plot the time series of `tas` for that region.
  - Using that time series, find the hottest and coldest 3-hourly periods in the entire dataset for that region. For those two time periods, plot the spatial distribution of `tas` over the entire globe using a map projection of your choice.

Rice University members can access [this "Gem"](https://gemini.google.com/gem/1nQDNg6wH03fM1mYn5Ds7oK9qIsFOjYYN?usp=sharing) (a large language model with specific prompts) on Google Gemini.
It is designed to help you with syntax and programming challenges related to these specific packages, and to help you translate concepts from Python (e.g., xarray) to Julia.
As with all LLMs (and humans), it can be wrong.
While it probably can answer the whole lab for you, that would defeat the entire purpose of learning how to use these tools, so please use it wisely and in accordance with the course AI policy.

## Code

```{julia}
#| output: false
using Pkg
lab_dir = dirname(@__FILE__)
Pkg.activate(lab_dir)
#Pkg.instantiate() # uncomment this the first time you run the lab to install packages, then comment it back
```

### Task 1
```{julia}
using YAXArrays
using YAXArrays: YAXArrays as YAX

a = YAXArray(rand(2,3))
```

```{julia}
# axes or dimensions with name and tick values
axlist = (
    YAX.time(range(1, 20, length=20)),
    lon(range(1, 10, length=10)),
    lat(range(1, 5, length=15)),
    Variables(["temperature", "precipitation"])
)

# the actual data matching the dimensions defined in axlist
data = rand(20, 10, 15, 2)

# metadata about the array
props = Dict(
    "origin" => "YAXArrays.jl example",
    "x" => "longitude",
    "y" => "latitude",
);

a2 = YAXArray(axlist, data, props)
```

```{julia}
a2[Variables=At("temperature"), time=1].data
```

### Task 2 

I tried to follow instructions but for some reason they did not work. 

```{julia}
using YAXArrays
using NetCDF
using Downloads: download

path = download("https://archive.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc", "example.nc")
ds = open_dataset(path)
```

```{julia}
tos = ds.tos
```

needed data selection 

```{julia}
tos[lon = At(1), lat = At(-79.5)]
```

```{julia}
using CFTime
time1 = DateTime360Day(2001,01,16)
tos[time = At(time1)]
```

```{julia}
tos[lon = 1:10, lat = 1:10]
```

```{julia}
tos[lon = 90 .. 180]
```

```{julia}
using IntervalSets
tos[lon =Interval{:open,:closed}(90,180)]
```

```{julia}
collect(tos.lat)
```

```{julia}
lookup(tos, :lon)
```

### Task 4 Plotting Maps 
```{julia}
using Zarr, YAXArrays, Dates
using DimensionalData
using CairoMakie, GeoMakie
using CairoMakie.GeometryBasics

store ="gs://cmip6/CMIP6/ScenarioMIP/DKRZ/MPI-ESM1-2-HR/ssp585/r1i1p1f1/3hr/tas/gn/v20190710/"
```

```{julia}
g = open_dataset(zopen(store, consolidated=true))
```

```{julia}
c = g["tas"];
```

```{julia}
ct1_slice = c[time = Near(Date("2015-01-01"))];
```

```{julia}
lon_d = lookup(ct1_slice, :lon)
lat_d = lookup(ct1_slice, :lat)
data_d = ct1_slice.data[:,:];
```

```{julia}
CairoMakie.activate!()

fig, ax, plt = heatmap(ct1_slice; colormap = :seaborn_icefire_gradient,
    axis = (; aspect=DataAspect()),
    figure = (; size = (1200,600), fontsize=24))
fig
```

```{julia}
δlon = (lon_d[2] - lon_d[1])/2
nlon = lon_d .- 180 .+ δlon
ndata = circshift(data_d, (192,1))
```

```{julia}
fig = Figure(;size=(1200,600))
ax = GeoAxis(fig[1,1])
surface!(ax, nlon, lat_d, ndata; colormap = :seaborn_icefire_gradient, shading=false)
cl=lines!(ax, GeoMakie.coastlines(), color = :white, linewidth=0.85)
translate!(cl, 0, 0, 1000)
fig
```

```{julia}
fig = Figure(; size=(1200,600))
ax = GeoAxis(fig[1,1]; dest = "+proj=moll")
surface!(ax, nlon, lat_d, ndata; colormap = :seaborn_icefire_gradient, shading=false)
cl=lines!(ax, GeoMakie.coastlines(), color = :white, linewidth=0.85)
translate!(cl, 0, 0, 1000)
fig
```

```{julia}
CairoMakie.activate!()

ds = replace(ndata, missing =>NaN)
sphere = uv_normal_mesh(Tesselation(Sphere(Point3f(0), 1), 128))

fig = Figure(backgroundcolor=:grey25, size=(500,500))
ax = LScene(fig[1,1], show_axis=false)
mesh!(ax, sphere; color = ds'[end:-1:1,:], shading=false,
    colormap = :seaborn_icefire_gradient)
zoom!(ax.scene, cameracontrols(ax.scene), 0.5)
rotate!(ax.scene, 2.5)
fig
```


```{julia}
using YAXArrays, Zarr, Dates
using GLMakie
using AlgebraOfGraphics
using GLMakie.GeometryBasics
using DataFrames
GLMakie.activate!()
```

```{julia}
store ="gs://cmip6/CMIP6/ScenarioMIP/DKRZ/MPI-ESM1-2-HR/ssp585/r1i1p1f1/3hr/tas/gn/v20190710/"
g = open_dataset(zopen(store, consolidated=true))
c = g["tas"];
```

```{julia}
dim_data = readcubedata(c[time=1]); # read into memory first!
```

### Task 5 

Select a single rectangular region. Compute the average tas over that region. 

```{julia}
ct2_slice = c[time = Near(Date("2019-05-25"))];
```


Result gave me an average temperature of 280.16K.

```{julia}
using Statistics, CairoMakie

# Define bounds
lat_min, lat_max = 41, 82
lon_min, lon_max = 19, 191   

# Extract coordinate and data arrays
lon_d1 = lookup(ct2_slice, :lon)
lat_d1 = lookup(ct2_slice, :lat)
data_d1 = ct2_slice.data[:, :]   # (lon × lat)

# Get indices within the region
lat_inds = findall(lat -> lat >= lat_min && lat <= lat_max, lat_d1)
lon_inds = findall(lon -> lon >= lon_min && lon <= lon_max, lon_d1)

# Subset arrays
lat_reg = lat_d1[lat_inds]
lon_reg = lon_d1[lon_inds]
data_reg = data_d1[lon_inds, lat_inds]   # (lon, lat)

# Compute summary statistics
regional_mean = mean(skipmissing(data_reg))

println("Regional mean value: ", regional_mean)


# Plot
CairoMakie.activate!()
fig, ax, plt = heatmap(
    lon_reg, lat_reg, data_reg';
    colormap = :seaborn_icefire_gradient,
    axis = (; aspect = DataAspect(), xlabel = "Longitude", ylabel = "Latitude"),
    figure = (; size = (1000, 600), fontsize = 20)
)
fig
```

Result gave me an average temperature of 277K.

```{julia}
using Dates
dim_time = c[time=DateTime("2019-05-25") .. DateTime("2019-05-25T21:00:00")] # subset 7 t steps
```

```{julia}
dim_time = readcubedata(dim_time); # read into memory first!
```

```{julia}
using Statistics, Dates

# 1) Pull coordinates & data
lon2 = collect(lookup(dim_time, :lon))
lat2 = collect(lookup(dim_time, :lat))
tt2  = collect(lookup(dim_time, :time))          # DateTime vector
A2   = Array(dim_time.data)                      # (lon, lat, time)

# 2) Region indices (0–360° longitudes)
lat_inds2 = findall(y -> 41 <= y <= 82,  lat2)
lon_inds2 = findall(x -> 19 <= x <= 191, lon2)

# 3) Mean over region for each time step (assumes each step is a 3-hour slice)
nt2 = size(A2, 3)
regional_means = [mean(skipmissing(@view A2[lon_inds2, lat_inds2, t])) for t in 1:nt2]

# 4) Locate coldest & warmest 3-hour windows
i_cold = argmin(regional_means)
i_warm = argmax(regional_means)

cold_K = regional_means[i_cold]; warm_K = regional_means[i_warm]
cold_C = cold_K - 273.15;        warm_C = warm_K - 273.15

println("Coldest 3-hour window:")
println("  Time:   ", tt2[i_cold])
println("  Mean:   ", round(cold_K, digits=2), " K  (", round(cold_C, digits=2), " °C)")

println("\nWarmest 3-hour window:")
println("  Time:   ", tt2[i_warm])
println("  Mean:   ", round(warm_K, digits=2), " K  (", round(warm_C, digits=2), " °C)")
```

Coldest 3-hour window:
  Time:   2019-05-25T21:00:00
  Mean:   276.83 K  (3.68 °C)

Warmest 3-hour window:
  Time:   2019-05-25T09:00:00
   Mean:   279.85 K  (6.7 °C)

Plotting the coldest one 
```{julia}
ct1_slicecold = c[time = Near(DateTime("2019-05-25T21:00:00"))];
```

```{julia}
lon_dcold = lookup(ct1_slicecold, :lon)
lat_dcold = lookup(ct1_slicecold, :lat)
data_dcold = ct1_slicecold.data[:,:];
```

```{julia}
GLMakie.activate!()

fig, ax, plt = heatmap(ct1_slicecold; colormap = :seaborn_icefire_gradient,
    axis = (; aspect=DataAspect()),
    figure = (; size = (1200,600), fontsize=24))
fig
```

ploting the hottest one 

```{julia}
ct1_slicehot = c[time = Near(DateTime("2019-05-25T09:00:00"))];
```

```{julia}
lon_dhot = lookup(ct1_slicehot, :lon)
lat_dhot = lookup(ct1_slicehot, :lat)
data_dhot = ct1_slicehot.data[:,:];
```

```{julia}
GLMakie.activate!()

fig, ax, plt = heatmap(ct1_slicehot; colormap = :seaborn_icefire_gradient,
    axis = (; aspect=DataAspect()),
    figure = (; size = (1200,600), fontsize=24))
fig
```